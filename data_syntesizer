"""
COMPARATIVE ANALYSIS: Load & Test All 5 FL Approaches
Purpose: Compare performance of FedAvg, FedProx, DP-FL, Vertical-FL, and Hierarchical-FL
Features: 
  - Simulated medical dataset creation
  - Load all trained models
  - Unified evaluation framework
  - Performance metrics & visualization
"""

import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset, Dataset
import torchvision.transforms as transforms
from sklearn.metrics import (accuracy_score, precision_score, recall_score, 
                            f1_score, roc_auc_score, confusion_matrix, hamming_loss)
import joblib
import json
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
import os
from PIL import Image


# ============================================================================
# 1. SYNTHETIC MEDICAL DATASET GENERATOR (Smaller than NIH - 5GB vs 112GB)
# ============================================================================

class SyntheticMedicalDataset(Dataset):
    """Generate synthetic chest X-ray-like images + multi-label disease labels"""
    
    def __init__(self, num_samples=5000, num_classes=14, seed=42):
        np.random.seed(seed)
        torch.manual_seed(seed)
        
        self.num_samples = num_samples
        self.num_classes = num_classes
        
        # Generate synthetic images (simulating chest X-rays)
        # Shape: (N, 3, 224, 224) for ResNet compatibility
        print(f"Generating {num_samples} synthetic medical images...")
        self.images = self._generate_synthetic_xrays(num_samples)
        
        # Generate multi-label targets (14 diseases)
        # Binary labels for each disease: 0 = absent, 1 = present
        self.labels = self._generate_disease_labels(num_samples, num_classes)
        
        print(f"Dataset created: {self.images.shape}, {self.labels.shape}")
    
    def _generate_synthetic_xrays(self, num_samples):
        """Generate synthetic X-ray-like images"""
        images = np.zeros((num_samples, 3, 224, 224), dtype=np.float32)
        
        for i in range(num_samples):
            # Create base image (simulating X-ray background)
            base = np.random.normal(0.5, 0.1, (3, 224, 224))
            
            # Add some structural patterns (simulate anatomy)
            for c in range(3):
                # Random Gaussian blobs (simulate organs/structures)
                y, x = np.ogrid[-224//2:224//2, -224//2:224//2]
                for _ in range(3):
                    cx = np.random.randint(50, 174)
                    cy = np.random.randint(50, 174)
                    radius = np.random.randint(20, 60)
                    mask = (x - cx)**2 + (y - cy)**2 <= radius**2
                    base[c, mask] += np.random.uniform(0.1, 0.3)
            
            # Add noise (simulating image artifacts)
            noise = np.random.normal(0, 0.05, (3, 224, 224))
            images[i] = np.clip(base + noise, 0, 1)
        
        return images
    
    def _generate_disease_labels(self, num_samples, num_classes):
        """Generate multi-label disease presence"""
        labels = np.zeros((num_samples, num_classes), dtype=np.float32)
        
        # Disease prevalence varies (simulating real-world distribution)
        disease_prevalence = np.random.uniform(0.1, 0.5, num_classes)
        
        for i in range(num_samples):
            for j in range(num_classes):
                # Add correlation between diseases (realistic)
                if j > 0 and labels[i, j-1] == 1:
                    prob = disease_prevalence[j] + 0.2  # Increased correlation
                else:
                    prob = disease_prevalence[j]
                
                labels[i, j] = 1 if np.random.random() < prob else 0
        
        return labels
    
    def __len__(self):
        return self.num_samples
    
    def __getitem__(self, idx):
        image = torch.FloatTensor(self.images[idx])
        label = torch.FloatTensor(self.labels[idx])
        return image, label


def create_medical_dataset(num_samples=5000, train_split=0.7, val_split=0.15, 
                          test_split=0.15, num_classes=14):
    """Create train/val/test splits of synthetic medical data"""
    print("\n" + "="*70)
    print("CREATING SYNTHETIC MEDICAL DATASET")
    print("="*70)
    
    dataset = SyntheticMedicalDataset(num_samples=num_samples, num_classes=num_classes)
    
    # Split dataset
    train_size = int(len(dataset) * train_split)
    val_size = int(len(dataset) * val_split)
    test_size = len(dataset) - train_size - val_size
    
    train_indices = np.random.choice(len(dataset), train_size, replace=False)
    remaining = np.setdiff1d(np.arange(len(dataset)), train_indices)
    val_indices = remaining[:val_size]
    test_indices = remaining[val_size:]
    
    train_dataset = torch.utils.data.Subset(dataset, train_indices)
    val_dataset = torch.utils.data.Subset(dataset, val_indices)
    test_dataset = torch.utils.data.Subset(dataset, test_indices)
    
    print(f"\nDataset Split:")
    print(f"  Train: {len(train_dataset)} samples")
    print(f"  Val:   {len(val_dataset)} samples")
    print(f"  Test:  {len(test_dataset)} samples")
    print(f"  Total: {len(dataset)} samples")
    print(f"\nDataset Size: ~{(len(dataset) * 224 * 224 * 3 * 4) / (1024**3):.2f} GB")
    print("(vs NIH Chest X-ray14: ~112 GB)")
    
    return dataset, train_dataset, val_dataset, test_dataset


